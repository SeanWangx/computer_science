# 2.1 线性表的定义和基本操作

## 2.1.1 线性表的定义

**线性表**是具有**相同**数据类型的n个数据元素的**有限**序列。一般表示为：L=(a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>)

1. 除了第一个元素外，每个元素有且仅有一个前驱；第一个元素只有后继，没有前驱。
2. 除最后一个元素外，每个元素有且仅有一个后继；最后一个元素只有前驱，没有后继。

## 2.1.2 线性表的基本操作

1. InitList(&L): 初始化表。构造一个空的线性表
2. Length(L): 求表长。返回线性表L的长度，即L中数据元素的个数
3. LocateElem(L, e): 按值查找操作
4. GetElem(L, i): 按位查找
5. ListInsert(&L, i, e): 插入操作
6. ListDelete(&L,i, &e): 删除操作
7. PrintList(L): 输出操作
8. Empty(L): 判空操作
9. DestroyList(&L): 销毁操作

# 2.2 线性表的顺序表示

## 2.2.1 顺序表的定义

线性表的**顺序存储**又称为**顺序表**。存储类型描述为：

```c
#define MaxSize 50              // 定义线性表的最大长度
typedef struct {
    ElemType data[MaxSize];     // 顺序表的元素
    int length;                 // 顺序表当前长度
} SqList;                       // 顺序表的类型定义
```

一维数组可以是**静态分配**的，也可以是**动态分配**的。静态分配时，由于数组的大小和空间是事先已经固定的，所以一旦空间占满，再加入新的数据会导致溢出。动态分配时若数据空间占满，可以另外开辟一个更大的存储空间替换原有存储空间。

```c
#define InitSize 100            // 表长度的初始定义
typedef struct {
    ElemType *data;             // 指示动态分配数组的指针
    int MaxSize, length;        // 数组的最大容量和当前个数
} SeqList;                      // 动态分配数组顺序表的类型定义
```

C的初始态分配语句为：

```c
L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize);
```

C++的初始态分配语句为：

```c++
L.data = new ElemType[InitSize];
```

特点：

1. **随机访问**，即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。
2. 存储密度高，每个结点只存储数据元素。
3. 逻辑上相邻的数据元素在物理上也相邻，所以**插入**和**删除**操作需要移动大量元素。

## 2.2.2 顺序表上基本操作的实现

### 1.插入操作

时间复杂度：O(n)
```c
bool ListInsert(SqList &L, int i, ElemType e) {
    // 将元素e插入到顺序表L的第i个位置
    if (i < 1 || L > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}
```

### 2.删除操作

时间复杂度：O(n)

```c
bool ListDelete (SqList &L, int i, ElemType &e) {
    // 删除顺序表L中第i个元素，并将删除的值用引用变量e返回
    if (i < 1 || i > L.length) {
        return false;
    }
    e = L.data[i - 1];
    for (int j = i; j < L.length; j++) {
        L.data[j - 1] = L.data[j];
    }
    L.length--;
    return true;
}
```

### 3.查找操作

时间复杂度：O(n)

```c
int LocateElem (SqList L, ElemType e) {
    // 查找顺序表中值为e的元素，并返回元素位序，否则0
    int i = 0;
    for (i = 0; i < L.length; i++) {
        if (L.data[i] == e) {
            return i + 1;
        }
    }
    return 0;
}
```

# 2.3 线性表的链式表示

## 2.3.1 单链表的定义

## 2.3.2 单链表上基本操作的实现

### 1. 采用头插法建立单链表
### 2. 采用尾插法建立单链表
### 3. 按序号查找结点值
### 4. 按值查找表结点
### 5. 插入结点操作
### 6. 删除结点操作
### 7. 求表长操作

## 2.3.3 双链表

### 1. 双链表的插入操作
### 2. 双链表的删除操作

## 2.3.4 循环链表

### 1. 循环单链表
### 2. 循环双链表

## 2.3.5 静态链表

## 2.3.6 顺序表和链表的比较

### 1. 存取方式
### 2. 逻辑结构与物理结构
### 3. 查找、插入和删除操作
### 4. 空间分配

## 2.3.7 选择

### 基于存储
### 基于运算
### 基于环境