# 指令寻址

寻找下一条将要执行的指令的地址

## 顺序寻址

通过程序计数器PC加1（1个指令字长），形成下一条指令地址。

> (PC) + 1 -> PC

(A)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。

## 跳跃寻址

通过转移类指令实现，下条指令的地址码由本条指令给出的计算方式计算出。

1. 绝对地址：由标记符直接得到
2. 相对地址：对于当前指令地址的偏移量

> PS. 跳跃的结果是当前指令修改PC值，所以下一条指令仍是PC给出

# 数据寻址

寻找操作数的地址，指令格式如下：

| 操作码 | 寻址特征 | 形式地址 |

## 隐含寻址

对于但地址指令格式来说，累加器ACC就是隐含地址。

1. 优点：缩短指令字长
2. 缺点：需要增加存储操作数或隐含地址的硬件

## 立即(数)寻址

给出的地址字段是操作数本身，成为立即数，用补码形式存放，可直接使用。

1. 优点：不需要访问主存，时间短
2. 缺点：立即数A的位数限制了范围

## 直接寻址

形式地址A就是操作数的真实地址EA，即EA = A。

1. 优点：简单，指令执行阶段只需要一次访问主存
2. 缺点：A的位数限制了寻址范围，操作数地址不易修改

## 间接寻址

相对于直接寻址的概念，地址字段给出的形式地址不是操作数的真正地址，而是有效地址所在存储单元的地址，即有效地址的地址，EA = (A)。

间接寻址可以多次进行，一次间接寻址需要访问主存两次，两次间接寻址需要访问主存三次！！

1. 优点：扩大寻址范围，便于编制程序
2. 缺点：指令在执行阶段要多次访存，速度较慢

> PS. 一般问到扩大寻址范围通常是寄存器间接寻址

## 寄存器寻址

形式地址为寄存器编号，即EA = R<sub>i</sub>，操作数为R<sub>i</sub>所指寄存器中内容

1. 优点：指令执行阶段不需要访问主存，只需要访问寄存器，且速度快
2. 缺点：寄存器价格昂贵，数量少

## 寄存器间接寻址

寄存器R<sub>i</sub>中给出的不是操作数，而是操作数的地址，即EA = (R<sub>i</sub>)。

1. 优点：相较于一般间接寻址速度快
2. 缺点：需要访问主存（操作数在主存中）

## 相对寻址

相对寻址是把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA = (PC) + A，其中A是相对于当前指令地址的位移量，由补码表示，且可正可负。

1. 优点：操作数地址不是固定的，便于程序浮动，广泛用于转移指令
2. 缺点：计算细节需要注意PC的自增行为(PC) + 1 -> PC

例如：对于转移指令JMPA，CPU从存储器取出一个字节时，自动执行(PC) + 1 -> PC，若转移指令地址为X，占2字节，则取出X后PC的值增加2，即(PC) = X + 2，执行该指令后，程序跳转到X + 2 + A的地址继续执行。

> PS. A的位数决定了操作数的寻址范围

## 基址寻址

基址寻址是将CPU中的基址寄存器（BR）中的内容加上指令格式中的形式地址A，而形成的有效地址，即EA = (BR) + A。其中基址寄存器既可以采用专用寄存器，也可以使用通用寄存器。

面向操作系统，基址寄存器内容由系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。

执行过程中基址寄存器中内容不变（作为基地址），但是形式地址可以改变（作为偏移量）。

1. 优点：可扩大寻址范围，利于多道程序设计，以及可用于编制浮动程序
2. 缺点：偏移量（形式地址A）的位数较短

## 变址寻址

有效地址EA等于指令字中形式地址A与变址寄存器IX的内容相加之和，即EA = (IX) + A。

变址寄存器面向用户，在执行程序过程中，变址寄存器中内容可以由用户改变（作为偏移量），但是形式地址A不变（作为基地址）。

1. 优点：可扩大寻址范围，偏移量（IX）的位数足以表示整个存储空间

与基址寻址的区别在于面向对象不同，且偏移量和基地址的选取不同。

## 堆栈寻址

硬堆栈、软堆栈，“后进先出（LIFO）”原则